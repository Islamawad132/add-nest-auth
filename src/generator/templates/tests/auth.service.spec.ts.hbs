import { Test, TestingModule } from '@nestjs/testing';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
import { AuthService } from './auth.service';
import { UsersService } from '../users/users.service';
{{#if features.emailService}}
import { MailService } from '../mail/mail.service';
{{/if}}
{{#if (eq orm "typeorm")}}
{{#if features.refreshTokens}}
import { getRepositoryToken } from '@nestjs/typeorm';
import { RefreshToken } from '../users/entities/refresh-token.entity';
{{/if}}
{{/if}}

jest.mock('bcrypt', () => ({
  compare: jest.fn(),
  hash: jest.fn(),
}));

describe('AuthService', () => {
  let authService: AuthService;
  let usersService: UsersService;
  let jwtService: JwtService;
{{#if (eq orm "typeorm")}}
{{#if features.refreshTokens}}
  let refreshTokenRepository: any;
{{/if}}
{{/if}}

  const mockUser = {
    id: 'test-uuid',
    email: 'test@example.com',
{{#if features.useUsername}}
    username: 'testuser',
{{/if}}
    password: '$2b$10$hashedpassword',
{{#if rbac.enabled}}
    roles: ['User'],
{{/if}}
  };

  const mockUsersService = {
    findByEmail: jest.fn(),
    findById: jest.fn(),
    create: jest.fn(),
    updatePassword: jest.fn(),
{{#if features.emailVerification}}
    setVerificationToken: jest.fn(),
    findByVerificationToken: jest.fn(),
    markEmailVerified: jest.fn(),
{{/if}}
{{#if features.resetPassword}}
    setResetToken: jest.fn(),
    findByResetToken: jest.fn(),
    clearResetToken: jest.fn(),
{{/if}}
{{#if features.accountLockout}}
    incrementFailedAttempts: jest.fn(),
    lockAccount: jest.fn(),
    resetFailedAttempts: jest.fn(),
{{/if}}
{{#if oauth}}
    findByOAuthProvider: jest.fn(),
    linkOAuthProvider: jest.fn(),
    createFromOAuth: jest.fn(),
{{/if}}
  };

  const mockJwtService = {
    sign: jest.fn().mockReturnValue('mock-jwt-token'),
    verify: jest.fn(),
  };

  const mockConfigService = {
    get: jest.fn((key: string, defaultValue?: string) => {
      const config: Record<string, string> = {
        BCRYPT_ROUNDS: '10',
        JWT_SECRET: 'test-secret',
      };
      return config[key] || defaultValue;
    }),
  };

{{#if features.emailService}}
  const mockMailService = {
{{#if features.emailVerification}}
    sendVerificationEmail: jest.fn(),
{{/if}}
{{#if features.resetPassword}}
    sendResetPasswordEmail: jest.fn(),
{{/if}}
  };
{{/if}}

{{#if (eq orm "typeorm")}}
{{#if features.refreshTokens}}
  const mockRefreshTokenRepository = {
    create: jest.fn(),
    save: jest.fn(),
    findOne: jest.fn(),
    remove: jest.fn(),
    delete: jest.fn(),
  };
{{/if}}
{{/if}}

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: UsersService, useValue: mockUsersService },
        { provide: JwtService, useValue: mockJwtService },
        { provide: ConfigService, useValue: mockConfigService },
{{#if features.emailService}}
        { provide: MailService, useValue: mockMailService },
{{/if}}
{{#if (eq orm "typeorm")}}
{{#if features.refreshTokens}}
        { provide: getRepositoryToken(RefreshToken), useValue: mockRefreshTokenRepository },
{{/if}}
{{/if}}
      ],
    }).compile();

    authService = module.get<AuthService>(AuthService);
    usersService = module.get<UsersService>(UsersService);
    jwtService = module.get<JwtService>(JwtService);
{{#if (eq orm "typeorm")}}
{{#if features.refreshTokens}}
    refreshTokenRepository = module.get(getRepositoryToken(RefreshToken));
{{/if}}
{{/if}}
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('validateUser', () => {
    it('should return user without password for valid credentials', async () => {
      mockUsersService.findByEmail.mockResolvedValue(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);

      const result = await authService.validateUser('test@example.com', 'password123');

      expect(result).toBeDefined();
      expect(result.email).toBe('test@example.com');
      expect(result.password).toBeUndefined();
    });

    it('should return null if user not found', async () => {
      mockUsersService.findByEmail.mockResolvedValue(null);

      const result = await authService.validateUser('wrong@example.com', 'password123');

      expect(result).toBeNull();
    });

    it('should return null if password is invalid', async () => {
      mockUsersService.findByEmail.mockResolvedValue(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);

      const result = await authService.validateUser('test@example.com', 'wrongpassword');

      expect(result).toBeNull();
    });

{{#if features.accountLockout}}
    it('should throw ForbiddenException when account is locked', async () => {
      const lockedUser = {
        ...mockUser,
        failedLoginAttempts: 5,
        lockUntil: new Date(Date.now() + 15 * 60 * 1000),
      };
      mockUsersService.findByEmail.mockResolvedValue(lockedUser);

      await expect(
        authService.validateUser('test@example.com', 'password123'),
      ).rejects.toThrow('Account is locked');
    });

    it('should increment failed attempts on wrong password', async () => {
      const userWithAttempts = { ...mockUser, failedLoginAttempts: 2 };
      mockUsersService.findByEmail.mockResolvedValue(userWithAttempts);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);

      await authService.validateUser('test@example.com', 'wrongpassword');

      expect(mockUsersService.incrementFailedAttempts).toHaveBeenCalledWith('test-uuid', 3);
    });

    it('should lock account after 5 failed attempts', async () => {
      const userWithAttempts = { ...mockUser, failedLoginAttempts: 4 };
      mockUsersService.findByEmail.mockResolvedValue(userWithAttempts);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);

      await authService.validateUser('test@example.com', 'wrongpassword');

      expect(mockUsersService.lockAccount).toHaveBeenCalledWith('test-uuid', 5, expect.any(Date));
    });

    it('should reset failed attempts on successful login', async () => {
      const userWithAttempts = { ...mockUser, failedLoginAttempts: 3, lockUntil: null };
      mockUsersService.findByEmail.mockResolvedValue(userWithAttempts);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);

      await authService.validateUser('test@example.com', 'password123');

      expect(mockUsersService.resetFailedAttempts).toHaveBeenCalledWith('test-uuid');
    });
{{/if}}
  });

  describe('login', () => {
    it('should return access token and user for valid credentials', async () => {
      mockUsersService.findByEmail.mockResolvedValue(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);
{{#if features.refreshTokens}}
      mockJwtService.sign.mockReturnValue('mock-jwt-token');
{{#if (eq orm "typeorm")}}
      mockRefreshTokenRepository.create.mockReturnValue({ token: 'mock-refresh-token' });
      mockRefreshTokenRepository.save.mockResolvedValue({ token: 'mock-refresh-token' });
{{/if}}
{{/if}}

      const result = await authService.login({ email: 'test@example.com', password: 'password123' });

      expect(result.accessToken).toBeDefined();
      expect(result.user.email).toBe('test@example.com');
    });

    it('should throw UnauthorizedException for invalid credentials', async () => {
      mockUsersService.findByEmail.mockResolvedValue(null);

      await expect(
        authService.login({ email: 'wrong@example.com', password: 'wrongpassword' }),
      ).rejects.toThrow(UnauthorizedException);
    });
  });

  describe('register', () => {
    it('should create user and return access token', async () => {
      const newUser = { ...mockUser };
      mockUsersService.create.mockResolvedValue(newUser);
      (bcrypt.hash as jest.Mock).mockResolvedValue('$2b$10$hashedpassword');
{{#if features.refreshTokens}}
      mockJwtService.sign.mockReturnValue('mock-jwt-token');
{{#if (eq orm "typeorm")}}
      mockRefreshTokenRepository.create.mockReturnValue({ token: 'mock-refresh-token' });
      mockRefreshTokenRepository.save.mockResolvedValue({ token: 'mock-refresh-token' });
{{/if}}
{{/if}}

      const result = await authService.register({
        email: 'new@example.com',
{{#if features.useUsername}}
        username: 'newuser',
{{/if}}
        password: 'StrongP@ss1',
      });

      expect(result.accessToken).toBeDefined();
      expect(result.user.email).toBe('test@example.com');
      expect(mockUsersService.create).toHaveBeenCalled();
    });
  });

  describe('changePassword', () => {
    it('should update password when current password is valid', async () => {
      mockUsersService.findById.mockResolvedValue(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);
      (bcrypt.hash as jest.Mock).mockResolvedValue('$2b$10$newhashedpassword');
      mockUsersService.updatePassword.mockResolvedValue(undefined);

      await authService.changePassword('test-uuid', {
        currentPassword: 'oldpassword',
        newPassword: 'NewP@ssword1',
      });

      expect(mockUsersService.updatePassword).toHaveBeenCalledWith('test-uuid', '$2b$10$newhashedpassword');
    });

    it('should throw UnauthorizedException for wrong current password', async () => {
      mockUsersService.findById.mockResolvedValue(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);

      await expect(
        authService.changePassword('test-uuid', {
          currentPassword: 'wrongpassword',
          newPassword: 'NewP@ssword1',
        }),
      ).rejects.toThrow(UnauthorizedException);
    });

    it('should throw UnauthorizedException if user not found', async () => {
      mockUsersService.findById.mockResolvedValue(null);

      await expect(
        authService.changePassword('nonexistent-uuid', {
          currentPassword: 'oldpassword',
          newPassword: 'NewP@ssword1',
        }),
      ).rejects.toThrow(UnauthorizedException);
    });
  });

{{#if features.emailVerification}}
  describe('verifyEmail', () => {
    it('should verify email with valid token', async () => {
      mockUsersService.findByVerificationToken.mockResolvedValue(mockUser);
      mockUsersService.markEmailVerified.mockResolvedValue(undefined);

      const result = await authService.verifyEmail('valid-token');

      expect(result.message).toBe('Email verified successfully');
      expect(mockUsersService.markEmailVerified).toHaveBeenCalledWith('test-uuid');
    });

    it('should throw NotFoundException for invalid token', async () => {
      mockUsersService.findByVerificationToken.mockResolvedValue(null);

      await expect(authService.verifyEmail('invalid-token')).rejects.toThrow();
    });
  });

  describe('resendVerification', () => {
    it('should generate new verification token', async () => {
      mockUsersService.findByEmail.mockResolvedValue({ ...mockUser, isEmailVerified: false });
      mockUsersService.setVerificationToken.mockResolvedValue(undefined);

      const result = await authService.resendVerification('test@example.com');

      expect(result.verificationToken).toBeDefined();
      expect(mockUsersService.setVerificationToken).toHaveBeenCalled();
    });
  });
{{/if}}

{{#if features.resetPassword}}
  describe('forgotPassword', () => {
    it('should generate reset token for existing user', async () => {
      mockUsersService.findByEmail.mockResolvedValue(mockUser);
      mockUsersService.setResetToken.mockResolvedValue(undefined);

      const result = await authService.forgotPassword({ email: 'test@example.com' });

      expect(result.resetToken).toBeDefined();
      expect(mockUsersService.setResetToken).toHaveBeenCalled();
    });

    it('should return success even if user not found (prevent enumeration)', async () => {
      mockUsersService.findByEmail.mockResolvedValue(null);

      const result = await authService.forgotPassword({ email: 'unknown@example.com' });

      expect(result.message).toBeDefined();
    });
  });

  describe('resetPassword', () => {
    it('should reset password with valid token', async () => {
      const futureDate = new Date();
      futureDate.setHours(futureDate.getHours() + 1);
      mockUsersService.findByResetToken.mockResolvedValue({ ...mockUser, passwordResetExpires: futureDate });
      (bcrypt.hash as jest.Mock).mockResolvedValue('$2b$10$newhashedpassword');
      mockUsersService.updatePassword.mockResolvedValue(undefined);
      mockUsersService.clearResetToken.mockResolvedValue(undefined);

      const result = await authService.resetPassword({ token: 'valid-token', newPassword: 'NewP@ssword1' });

      expect(result.message).toBe('Password reset successfully');
      expect(mockUsersService.updatePassword).toHaveBeenCalled();
      expect(mockUsersService.clearResetToken).toHaveBeenCalled();
    });

    it('should throw BadRequestException for invalid token', async () => {
      mockUsersService.findByResetToken.mockResolvedValue(null);

      await expect(
        authService.resetPassword({ token: 'invalid-token', newPassword: 'NewP@ssword1' }),
      ).rejects.toThrow();
    });
  });
{{/if}}

{{#if features.refreshTokens}}
  describe('logout', () => {
    it('should delete the refresh token', async () => {
{{#if (eq orm "typeorm")}}
      const storedToken = { id: '1', token: 'refresh-token' };
      mockRefreshTokenRepository.findOne.mockResolvedValue(storedToken);
      mockRefreshTokenRepository.remove.mockResolvedValue(undefined);
{{/if}}

      await authService.logout('refresh-token');

{{#if (eq orm "typeorm")}}
      expect(mockRefreshTokenRepository.findOne).toHaveBeenCalled();
{{/if}}
    });
  });
{{/if}}
});
